/**
 * Asciistrator - SVG Exporter
 * 
 * Exports ASCII art as scalable vector graphics.
 * 
 * @version 1.0.0
 */

import BaseExporter from './BaseExporter.js';
import { ExportCategory } from '../ExporterRegistry.js';

// ==========================================
// SVG EXPORTER
// ==========================================

/**
 * SVG vector graphics exporter
 */
export class SVGExporter extends BaseExporter {
    constructor(config = {}) {
        super(config);
    }
    
    // ==========================================
    // METADATA
    // ==========================================
    
    get id() { return 'svg'; }
    get name() { return 'SVG'; }
    get description() { return 'Export as scalable vector graphics (.svg)'; }
    get fileExtension() { return '.svg'; }
    get mimeType() { return 'image/svg+xml'; }
    get category() { return ExportCategory.Vector; }
    
    // ==========================================
    // CAPABILITIES
    // ==========================================
    
    get supportsColors() { return true; }
    get supportsComponents() { return false; }
    get supportsLayers() { return true; }
    get supportsAnimations() { return false; }
    
    get defaultOptions() {
        return {
            ...super.defaultOptions,
            cellWidth: 10,
            cellHeight: 18,
            fontFamily: 'Consolas, "Courier New", monospace',
            fontSize: 14,
            backgroundColor: '#1a1a2e',
            defaultColor: '#e0e0e0',
            padding: 20,
            includeBackground: true,
            embedFont: false,
            optimizeOutput: true,
            title: 'ASCII Art',
            description: 'Generated by Asciistrator'
        };
    }
    
    // ==========================================
    // EXPORT IMPLEMENTATION
    // ==========================================
    
    /**
     * Export buffer to SVG
     * @protected
     */
    _doExport(document, options) {
        const buffer = this._getBuffer(document);
        if (!buffer) {
            return this._createEmptySvg(options);
        }
        
        const { width, height } = this._getBufferDimensions(buffer);
        
        // Calculate dimensions
        const svgWidth = width * options.cellWidth + options.padding * 2;
        const svgHeight = height * options.cellHeight + options.padding * 2;
        
        // Start SVG
        let svg = this._createSvgHeader(svgWidth, svgHeight, options);
        
        // Add metadata
        svg += this._createMetadata(options);
        
        // Add defs (for potential gradients, patterns, etc.)
        svg += this._createDefs(options);
        
        // Add background
        if (options.includeBackground) {
            svg += this._createBackground(svgWidth, svgHeight, options);
        }
        
        // Create text group
        svg += `  <g id="ascii-content" font-family="${this._escapeXml(options.fontFamily)}" font-size="${options.fontSize}">\n`;
        
        // Render characters
        if (options.optimizeOutput) {
            svg += this._renderOptimized(buffer, width, height, options);
        } else {
            svg += this._renderSimple(buffer, width, height, options);
        }
        
        // Close text group
        svg += '  </g>\n';
        
        // Close SVG
        svg += '</svg>';
        
        return svg;
    }
    
    /**
     * Create SVG header
     * @private
     */
    _createSvgHeader(width, height, options) {
        return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink"
     width="${width}" 
     height="${height}" 
     viewBox="0 0 ${width} ${height}"
     role="img"
     aria-label="${this._escapeXml(options.title)}">
`;
    }
    
    /**
     * Create SVG metadata
     * @private
     */
    _createMetadata(options) {
        return `  <title>${this._escapeXml(options.title)}</title>
  <desc>${this._escapeXml(options.description)}</desc>
  <metadata>
    <generator>Asciistrator</generator>
    <created>${new Date().toISOString()}</created>
  </metadata>
`;
    }
    
    /**
     * Create SVG defs section
     * @private
     */
    _createDefs(options) {
        let defs = '  <defs>\n';
        
        // Add font embedding if requested
        if (options.embedFont) {
            defs += `    <style type="text/css">
      @font-face {
        font-family: 'AsciiFont';
        src: local('Consolas'), local('Courier New'), local('monospace');
      }
    </style>\n`;
        }
        
        defs += '  </defs>\n';
        return defs;
    }
    
    /**
     * Create background rect
     * @private
     */
    _createBackground(width, height, options) {
        return `  <rect id="background" width="${width}" height="${height}" fill="${options.backgroundColor}"/>\n`;
    }
    
    /**
     * Render characters - simple method (one text element per character)
     * @private
     */
    _renderSimple(buffer, width, height, options) {
        let svg = '';
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const char = this._getChar(buffer, x, y);
                if (char === ' ') continue; // Skip spaces
                
                const color = this._getColor(buffer, x, y) || options.defaultColor;
                const px = options.padding + x * options.cellWidth;
                const py = options.padding + y * options.cellHeight + options.fontSize;
                
                svg += `    <text x="${px}" y="${py}" fill="${color}">${this._escapeXml(char)}</text>\n`;
            }
        }
        
        return svg;
    }
    
    /**
     * Render characters - optimized method (groups consecutive same-color text)
     * @private
     */
    _renderOptimized(buffer, width, height, options) {
        let svg = '';
        
        for (let y = 0; y < height; y++) {
            const py = options.padding + y * options.cellHeight + options.fontSize;
            let currentColor = null;
            let currentText = '';
            let startX = 0;
            
            for (let x = 0; x < width; x++) {
                const char = this._getChar(buffer, x, y);
                const color = this._getColor(buffer, x, y) || options.defaultColor;
                
                // If color changes or we hit a space after text, emit current span
                if (color !== currentColor || (char === ' ' && currentText.length > 0 && !currentText.endsWith(' '))) {
                    if (currentText.trimEnd().length > 0) {
                        const px = options.padding + startX * options.cellWidth;
                        svg += `    <text x="${px}" y="${py}" fill="${currentColor}">${this._escapeXml(currentText.trimEnd())}</text>\n`;
                    }
                    currentColor = color;
                    currentText = char;
                    startX = x;
                } else {
                    currentText += char;
                }
            }
            
            // Emit remaining text for this line
            if (currentText.trimEnd().length > 0) {
                const px = options.padding + startX * options.cellWidth;
                svg += `    <text x="${px}" y="${py}" fill="${currentColor}">${this._escapeXml(currentText.trimEnd())}</text>\n`;
            }
        }
        
        return svg;
    }
    
    /**
     * Create empty SVG
     * @private
     */
    _createEmptySvg(options) {
        const width = 200;
        const height = 100;
        
        return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
  <rect width="${width}" height="${height}" fill="${options.backgroundColor}"/>
  <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="${options.defaultColor}">Empty</text>
</svg>`;
    }
    
    /**
     * Validation
     * @protected
     */
    _doValidate(document, result) {
        const buffer = this._getBuffer(document);
        if (buffer) {
            const { width, height } = this._getBufferDimensions(buffer);
            
            // Warn about large exports
            if (width * height > 10000) {
                result.addWarning(
                    'LARGE_EXPORT',
                    'Large document may result in slow rendering',
                    { width, height, chars: width * height }
                );
            }
        }
    }
}

// ==========================================
// DEFAULT EXPORT
// ==========================================

export default SVGExporter;
